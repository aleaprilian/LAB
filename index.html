<!DOCTYPE html>
<html lang="id">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>LAB MERDEKA - VR Front Screen</title>
    <style>
        body { margin: 0; overflow: hidden; font-family: 'Segoe UI', sans-serif; background-color: #111; }
        
        /* Panel Info Ruangan */
        #ui-container {
            position: absolute;
            top: 20px;
            right: 20px;
            width: 300px;
            background: rgba(20, 20, 30, 0.9);
            border-left: 4px solid #00d2ff;
            padding: 20px;
            color: #fff;
            border-radius: 8px;
            display: none; 
            z-index: 10;
            box-shadow: 0 0 20px rgba(0,0,0,0.5);
            pointer-events: auto; /* allow interaction if needed */
        }

        /* Judul */
        #title-card {
            position: absolute;
            top: 20px;
            left: 20px;
            background: rgba(20, 20, 30, 0.8);
            padding: 15px 25px;
            border-radius: 8px;
            color: white;
            border-bottom: 3px solid #00d2ff;
            user-select: none;
            z-index: 10;
        }

        .tag {
            display: inline-block;
            margin-top: 8px;
            padding: 6px 8px;
            background: rgba(0,210,255,0.08);
            border: 1px solid rgba(0,210,255,0.15);
            color: #aeeeff;
            border-radius: 6px;
            font-size: 0.85rem;
        }

        h1 { margin: 0; font-size: 1.5rem; }
        h2 { margin-top: 0; color: #00d2ff; font-size: 1.2rem; }
        p { font-size: 0.9rem; color: #ccc; }
        
        /* Instruksi Kontrol Dynamic */
        #controls-help {
            position: absolute;
            bottom: 20px;
            left: 20px;
            color: rgba(255,255,255,0.8);
            font-size: 0.9rem;
            background: rgba(0,0,0,0.6);
            padding: 15px;
            border-radius: 8px;
            pointer-events: none;
            z-index: 10;
            border: 1px solid #444;
            transition: all 0.3s;
        }
        .key { background: #444; color: #fff; padding: 2px 6px; border-radius: 4px; font-weight: bold; font-family: monospace; }
        
        /* Tombol Masuk FPV */
        #fpv-container {
            position: absolute;
            bottom: 40px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 20;
            text-align: center;
        }

        #start-fpv-btn {
            background: rgba(0, 210, 255, 0.15);
            border: 2px solid #00d2ff;
            color: #00d2ff;
            padding: 12px 30px;
            font-size: 1.1rem;
            border-radius: 50px;
            cursor: pointer;
            font-weight: bold;
            text-transform: uppercase;
            letter-spacing: 1px;
            backdrop-filter: blur(5px);
            transition: 0.3s;
            box-shadow: 0 0 10px rgba(0, 210, 255, 0.2);
        }
        #start-fpv-btn:hover {
            background: #00d2ff;
            color: #000;
            box-shadow: 0 0 25px rgba(0, 210, 255, 0.6);
        }

        /* Hint ESC */
        #esc-hint {
            position: absolute;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(0,0,0,0.7);
            color: #fff;
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 1rem;
            display: none;
            z-index: 20;
            border: 1px solid #555;
        }
        #esc-hint b { color: #00d2ff; }

    </style>
</head>
<body>

    <!-- UI Navigasi -->
    <div id="fpv-container">
        <button id="start-fpv-btn" onclick="enterFPV()">ðŸš¶ MULAI</button>
    </div>

    <div id="esc-hint">Tekan <b>ESC</b> untuk Kembali ke Atas</div>

    <div id="title-card">
        <h1>LAB MERDEKA</h1>
    </div>

    <div id="ui-container">
        <h2 id="room-name">Ruangan</h2>
        <p id="room-desc">Deskripsi ruangan.</p>
        <div id="room-tech"></div>
    </div>

    <div id="controls-help">
        <div id="help-overview">
            <div style="margin-bottom:8px; color:#00d2ff; border-bottom:1px solid #555; padding-bottom:5px;"></div>
            <div><span class="key">Kiri Mouse</span> : Putar Ruangan</div>
            <div><span class="key">Kanan Mouse</span> : Geser Ruangan</div>
            <div><span class="key">Scroll</span> : Zoom</div>
        </div>
        <div id="help-fpv" style="display:none;">
            <div style="margin-bottom:8px; color:#00d2ff; border-bottom:1px solid #555; padding-bottom:5px;"><strong></strong></div>
            <div><span class="key">W</span> <span class="key">A</span> <span class="key">S</span> <span class="key">D</span> : Berjalan</div>
            <div><span class="key">Kiri Mouse</span> : Tengok Kanan/Kiri</div>
            <div><span class="key">Scroll</span> : Maju / Mundur Cepat</div>
            <div><span class="key">ESC</span> : Keluar</div>
        </div>
    </div>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.9.1/gsap.min.js"></script>

    <script>
    {
        let isFPV = false;

        const labData = {
            "collab": {
                name: "Grand Collaborative Space",
                desc: "Area diskusi utama yang luas dengan akses pintu masuk yang terpusat.",
                tech: "Multiple Smart Displays, Laptop Stations, 100-inch Wall Display"
            },
            "production": {
                name: "Ruang Media Production",
                desc: "Studio rekaman profesional dengan Greenscreen Cyclorama, pencahayaan softbox, kamera tripod, dan stasiun editing high-end.",
                tech: "Green Screen Cyclorama, Softbox Lights, 4K Camera Tripod, RGB Editing PC"
            },
            "vr": {
                name: "Ruang VR Testing",
                desc: "Arena VR luas dengan Command Center sudut. Dilengkapi Dual Screen di dinding depan.",
                tech: "VR Headsets, Motion Tracking, L-Desk, Dual Front Screens"
            },
            "ux": {
                name: "Ruang UX Testing",
                desc: "Lab pengujian pengguna (User Testing).",
                tech: "One-Way Mirror, Eye Tracking"
            },
            "ai": {
                name: "Ruang AI & Learning Analytics",
                desc: "Pusat analisis data dengan Data Wall besar berisi grafik, Server Rack, dan Workstation monitoring.",
                tech: "Big Data Screen, AI Server Rack, Dual Monitor Workstations"
            },
            "storage": {
                name: "Storage",
                desc: "Gudang penyimpanan aset (Level Bawah).",
                tech: "Secure Cabinets"
            }
        };

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x15151a);
        scene.fog = new THREE.Fog(0x15151a, 20, 150);

        const camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 1000);
        
        // Start view focuses on the VR Room
        const POS_OVERVIEW = new THREE.Vector3(32.5, 40, 40); 
        const TARGET_OVERVIEW = new THREE.Vector3(32.5, 0, -10); 
        
        const POS_FPV = new THREE.Vector3(0, 2.5, 30); 
        const TARGET_FPV = new THREE.Vector3(0, 2.5, 29.9); 

        camera.position.copy(POS_OVERVIEW);

        const renderer = new THREE.WebGLRenderer({ antialias: true });

        // fix for Hi-DPI / Retina displays (prevents blurriness)
        renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
        renderer.setSize(window.innerWidth, window.innerHeight);

        renderer.shadowMap.enabled = true;
        renderer.shadowMap.type = THREE.PCFSoftShadowMap;
        renderer.domElement.tabIndex = 1; 
        document.body.appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.dampingFactor = 0.1;
        controls.target.copy(TARGET_OVERVIEW);
        controls.maxPolarAngle = Math.PI / 2 - 0.05;
        
        const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
        dirLight.position.set(20, 50, 40);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // MATERIALS
        const matFloor = new THREE.MeshStandardMaterial({ color: 0x3d4c53, roughness: 0.8 });
        const matWall = new THREE.MeshStandardMaterial({ color: 0xeeeeee, roughness: 0.4 });
        const matGlass = new THREE.MeshPhongMaterial({ color: 0x88ccff, opacity: 0.2, transparent: true, side: THREE.DoubleSide });
        const matFurniture = new THREE.MeshStandardMaterial({ color: 0x333333 }); 
        const matTable = new THREE.MeshStandardMaterial({ color: 0xffffff }); 
        const matScreen = new THREE.MeshStandardMaterial({ color: 0x00d2ff, emissive: 0x0055aa, emissiveIntensity: 0.5 });
        const matHolo = new THREE.MeshPhongMaterial({ color: 0x00ffff, opacity: 0.6, transparent: true, side: THREE.DoubleSide });
        const matGS = new THREE.MeshStandardMaterial({ color: 0x00aa00, roughness: 1 }); 
        const matCarpet = new THREE.MeshStandardMaterial({ color: 0x3d4c53 }); 
        const matNeon = new THREE.MeshBasicMaterial({ color: 0x00d2ff });
        const matSensor = new THREE.MeshStandardMaterial({ color: 0x111111 });
        const matFabric = new THREE.MeshStandardMaterial({ color: 0x555555 });
        const matWood = new THREE.MeshStandardMaterial({ color: 0x8b5a2b });
        const matWoodAccent = new THREE.MeshStandardMaterial({ color: 0xd2a679, roughness: 0.6 });
        const matServer = new THREE.MeshStandardMaterial({ color: 0x111111, roughness: 0.7, metalness: 0.3 }); 
        const matPaper = new THREE.MeshStandardMaterial({ color: 0xffffff });
        const matCup = new THREE.MeshStandardMaterial({ color: 0xff5500 });
        const matDarkGadget = new THREE.MeshStandardMaterial({ color: 0x222222 });
        const matVRRug = new THREE.MeshStandardMaterial({ color: 0x999999, roughness: 1 });
        const matPot = new THREE.MeshStandardMaterial({ color: 0x8B4513 });
        const matPlantGreen = new THREE.MeshStandardMaterial({ color: 0x228B22 });
        const matSoftbox = new THREE.MeshBasicMaterial({ color: 0xffffff }); 
        const matAcoustic = new THREE.MeshStandardMaterial({ color: 0x888888, roughness: 0.9 }); 
        
        const matWoodPanel = new THREE.MeshStandardMaterial({ color: 0x5c4033, roughness: 0.7 }); 
        const matModernChair = new THREE.MeshStandardMaterial({ color: 0x333333, roughness: 0.8 }); 
        const matWhiteTable = new THREE.MeshStandardMaterial({ color: 0xffffff, roughness: 0.2 }); 
        const matCityLights = new THREE.MeshBasicMaterial({ color: 0x050510 }); 
        const matLaptop = new THREE.MeshStandardMaterial({ color: 0xaaaaaa });
        const matServerLights = new THREE.MeshBasicMaterial({ color: 0x00ff00 }); 
        const matCeilingLight = new THREE.MeshBasicMaterial({ color: 0xffffff });
        
        const matChartRed = new THREE.MeshLambertMaterial({ color: 0xff3333 });
        const matChartGreen = new THREE.MeshLambertMaterial({ color: 0x33ff33 });
        const matChartBlue = new THREE.MeshLambertMaterial({ color: 0x3333ff });
        const matChartYellow = new THREE.MeshLambertMaterial({ color: 0xffff33 });
        const matScreenDark = new THREE.MeshStandardMaterial({ color: 0x001133, emissive: 0x000510, roughness: 0.2 });
        const matScreenFrame = new THREE.MeshStandardMaterial({ color: 0x555555, metalness: 0.8, roughness: 0.2 });
        const matRackMetal = new THREE.MeshStandardMaterial({ color: 0x888888, metalness: 0.6, roughness: 0.4 }); 
        const matCardboard = new THREE.MeshStandardMaterial({ color: 0xc19a6b }); 
        const matPlasticBox = new THREE.MeshPhysicalMaterial({ color: 0xeeeeee, transparent: true, opacity: 0.5, roughness: 0.2 }); 
        const matCabinet = new THREE.MeshStandardMaterial({ color: 0x333333, metalness: 0.4, roughness: 0.5 });
        const matNeonRed = new THREE.MeshBasicMaterial({ color: 0xff0055 });

        const group = new THREE.Group();
        scene.add(group);

        function createBox(w, h, d, x, y, z, mat, shadow=true) {
            const mesh = new THREE.Mesh(new THREE.BoxGeometry(w, h, d), mat);
            mesh.position.set(x, y, z);
            mesh.castShadow = shadow;
            mesh.receiveShadow = shadow;
            group.add(mesh);
            return mesh;
        }
        function createMonitor(x, y, z, rotY=0) {
            const s = new THREE.Mesh(new THREE.BoxGeometry(1.2, 0.7, 0.05), matFurniture);
            s.position.set(x, y+0.35, z); s.rotation.y = rotY; group.add(s);
            const g = new THREE.Mesh(new THREE.PlaneGeometry(1.1, 0.6), matScreen);
            g.position.set(0,0,0.03); s.add(g);
            createBox(0.1, 0.4, 0.1, x, y+0.2, z, matFurniture);
        }
        function createSensor(x, y, z) {
            const s = new THREE.Mesh(new THREE.SphereGeometry(0.25, 16, 16), matSensor);
            s.position.set(x, y, z); group.add(s);
        }
        function createChair(x, z, rotY=0) {
            const seat = new THREE.Mesh(new THREE.BoxGeometry(1, 0.1, 1), matFabric);
            seat.position.set(x, 0.5, z); seat.rotation.y = rotY; group.add(seat);
            const back = new THREE.Mesh(new THREE.BoxGeometry(1, 1, 0.1), matFabric);
            back.position.set(0, 0.5, 0.45); seat.add(back);
            const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.1, 0.5), matFurniture);
            leg.position.set(0, -0.25, 0); seat.add(leg);
        }
        function createPlant(x, y, z) {
            const pot = new THREE.Mesh(new THREE.CylinderGeometry(0.4, 0.3, 0.6, 16), matPot);
            pot.position.set(x, y + 0.3, z); pot.castShadow = true; group.add(pot);
            const leaves = new THREE.Mesh(new THREE.DodecahedronGeometry(0.6, 0), matPlantGreen);
            leaves.position.set(x, y + 0.9, z); group.add(leaves);
        }
        function createVRHeadset(x, y, z, rotY) {
            const hGroup = new THREE.Group();
            hGroup.position.set(x, y, z); hGroup.rotation.y = rotY;
            const visor = new THREE.Mesh(new THREE.BoxGeometry(0.5, 0.25, 0.3), new THREE.MeshStandardMaterial({color: 0x111111, roughness: 0.2}));
            hGroup.add(visor);
            const front = new THREE.Mesh(new THREE.PlaneGeometry(0.4, 0.1), matNeon);
            front.position.set(0, 0, 0.16); hGroup.add(front);
            const strap = new THREE.Mesh(new THREE.TorusGeometry(0.2, 0.03, 8, 20, 4), new THREE.MeshStandardMaterial({color: 0x333333}));
            strap.rotation.x = Math.PI/2; strap.position.z = -0.15; hGroup.add(strap);
            group.add(hGroup);
            return hGroup;
        }
        
        function createVRCabinet(x, y, z, rotY) {
            const cabGroup = new THREE.Group();
            cabGroup.position.set(x, y, z);
            cabGroup.rotation.y = rotY;
            const back = new THREE.Mesh(new THREE.BoxGeometry(2.5, 4, 0.1), new THREE.MeshStandardMaterial({color: 0x222222}));
            back.position.set(0, 2, -0.5); cabGroup.add(back);
            const glassBox = new THREE.Mesh(new THREE.BoxGeometry(2.5, 4, 1), new THREE.MeshPhysicalMaterial({ color: 0x88ccff, transmission: 0.95, opacity: 0.3, metalness: 0, roughness: 0, transparent: true, thickness: 0.05 }));
            glassBox.position.set(0, 2, 0); cabGroup.add(glassBox);
            for(let i=1; i<=3; i++) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(2.3, 0.05, 0.8), matNeon);
                shelf.position.set(0, i*1.0, 0); cabGroup.add(shelf);
                const shelfLight = new THREE.PointLight(0x00d2ff, 0.5, 2);
                shelfLight.position.set(0, i*1.0 + 0.4, 0); cabGroup.add(shelfLight);
                const vr1 = createVRHeadset(-0.6, i*1.0 + 0.2, 0.1, 0);
                const vr2 = createVRHeadset(0.6, i*1.0 + 0.2, 0.1, 0);
                cabGroup.add(vr1); cabGroup.add(vr2);
            }
            group.add(cabGroup);
        }
        
        function createSoftbox(x, y, z, rotY) {
            const sbGroup = new THREE.Group();
            sbGroup.position.set(x, y, z); sbGroup.rotation.y = rotY;
            const leg1 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2), matFurniture);
            leg1.position.y = 1; leg1.rotation.x = 0.3; sbGroup.add(leg1);
            const leg2 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2), matFurniture);
            leg2.position.y = 1; leg2.rotation.x = -0.3; leg2.rotation.z = 0.3; sbGroup.add(leg2);
            const leg3 = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 2), matFurniture);
            leg3.position.y = 1; leg3.rotation.x = -0.3; leg3.rotation.z = -0.3; sbGroup.add(leg3);
            const pole = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 3.5), matFurniture);
            pole.position.y = 1.75; sbGroup.add(pole);
            const boxGeo = new THREE.BoxGeometry(1.5, 1.5, 0.5);
            const box = new THREE.Mesh(boxGeo, matFurniture);
            box.position.y = 3.5; sbGroup.add(box);
            const lightFace = new THREE.Mesh(new THREE.PlaneGeometry(1.4, 1.4), matSoftbox);
            lightFace.position.set(0, 3.5, 0.26); sbGroup.add(lightFace);
            group.add(sbGroup);
        }

        function createTripodCamera(x, y, z, rotY) {
            const camGroup = new THREE.Group();
            camGroup.position.set(x, y, z); camGroup.rotation.y = rotY;
            const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.1, 2), matFurniture);
            leg.position.y = 1; leg.rotation.z = 0.2; camGroup.add(leg);
            const leg2 = leg.clone(); leg2.rotation.z = -0.2; leg2.rotation.x = 0.2; camGroup.add(leg2);
            const leg3 = leg.clone(); leg3.rotation.z = -0.2; leg3.rotation.x = -0.2; camGroup.add(leg3);
            const body = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.8), matDarkGadget);
            body.position.y = 2.2; camGroup.add(body);
            const lens = new THREE.Mesh(new THREE.CylinderGeometry(0.15, 0.15, 0.3), matDarkGadget);
            lens.rotation.x = Math.PI/2; lens.position.set(0, 2.2, 0.5); camGroup.add(lens);
            const screen = new THREE.Mesh(new THREE.PlaneGeometry(0.3, 0.2), matScreen);
            screen.position.set(-0.21, 2.2, 0); screen.rotation.y = -Math.PI/2; camGroup.add(screen);
            group.add(camGroup);
        }

        function createModernChair(x, y, z, rotY = 0) {
            const chairGroup = new THREE.Group();
            chairGroup.position.set(x, y, z);
            chairGroup.rotation.y = rotY;
            const seat = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.1, 0.6), matModernChair);
            seat.position.y = 0.5; chairGroup.add(seat);
            const backrest = new THREE.Mesh(new THREE.BoxGeometry(0.7, 0.6, 0.1), matModernChair);
            backrest.position.set(0, 0.8, 0.3); chairGroup.add(backrest);
            const leg = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.5), matFurniture);
            leg.position.y = 0.25; chairGroup.add(leg);
            const base = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.05), matFurniture);
            base.position.y = 0.025; chairGroup.add(base);
            group.add(chairGroup);
        }
        
        function createServerRack(x, y, z, rotY=0) {
            const rackGroup = new THREE.Group();
            rackGroup.position.set(x, y, z); rackGroup.rotation.y = rotY;
            const frame = new THREE.Mesh(new THREE.BoxGeometry(1.5, 3.5, 1.5), matServer);
            frame.position.y = 1.75; rackGroup.add(frame);
            const glass = new THREE.Mesh(new THREE.BoxGeometry(1.4, 3.4, 0.1), matGlass);
            glass.position.set(0, 1.75, 0.75); rackGroup.add(glass);
            for(let i=0; i<5; i++) {
                const light = new THREE.Mesh(new THREE.PlaneGeometry(1.2, 0.05), matServerLights);
                light.position.set(0, 1 + i*0.5, 0.71); rackGroup.add(light);
            }
            group.add(rackGroup);
        }

        function createClosedCabinet(x, y, z, rotY=0) {
            const cabGroup = new THREE.Group();
            cabGroup.position.set(x, y, z);
            cabGroup.rotation.y = rotY;
            const body = new THREE.Mesh(new THREE.BoxGeometry(2, 3, 1), matCabinet);
            body.position.y = 1.5; cabGroup.add(body);
            const line = new THREE.Mesh(new THREE.BoxGeometry(0.02, 2.8, 0.02), new THREE.MeshStandardMaterial({color:0x111111}));
            line.position.set(0, 1.5, 0.51); cabGroup.add(line);
            const handle1 = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.3), new THREE.MeshStandardMaterial({color:0x888888}));
            handle1.position.set(-0.15, 1.5, 0.55); cabGroup.add(handle1);
            const handle2 = new THREE.Mesh(new THREE.CylinderGeometry(0.03, 0.03, 0.3), new THREE.MeshStandardMaterial({color:0x888888}));
            handle2.position.set(0.15, 1.5, 0.55); cabGroup.add(handle2);
            group.add(cabGroup);
        }

        function createWallTV(x, y, z, rotY) {
            const tvGroup = new THREE.Group();
            tvGroup.position.set(x, y, z);
            tvGroup.rotation.y = rotY; 
            const frameGeo = new THREE.BoxGeometry(0.1, 3.4, 9.0); 
            const frame = new THREE.Mesh(frameGeo, new THREE.MeshStandardMaterial({color: 0x111111, metalness: 0.8, roughness: 0.2}));
            tvGroup.add(frame);
            const screenGeo = new THREE.BoxGeometry(0.05, 3.2, 4.2);
            const screen1 = new THREE.Mesh(screenGeo, matScreen);
            screen1.position.set(0.05, 0, -2.2); tvGroup.add(screen1);
            const screen2 = new THREE.Mesh(screenGeo, matScreen);
            screen2.position.set(0.05, 0, 2.2); tvGroup.add(screen2);
            const sbar = new THREE.Mesh(new THREE.BoxGeometry(0.15, 0.15, 8.8), new THREE.MeshStandardMaterial({color: 0x222222}));
            sbar.position.set(0.05, -1.8, 0); tvGroup.add(sbar);
            const cam = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.1, 0.8), new THREE.MeshStandardMaterial({color: 0x111111}));
            cam.position.set(0.05, 1.8, 0); tvGroup.add(cam);
            const light = new THREE.PointLight(0x00d2ff, 0.8, 15);
            light.position.set(3, 0, 0); tvGroup.add(light);
            group.add(tvGroup);
        }

        function createChartScreen(x, y, z) {
             const chartGroup = new THREE.Group();
             chartGroup.position.set(x, y, z);
             chartGroup.rotation.y = -Math.PI/2; 
             const frame = new THREE.Mesh(new THREE.BoxGeometry(8.2, 3.7, 0.05), matScreenFrame);
             chartGroup.add(frame);
             const screen = new THREE.Mesh(new THREE.BoxGeometry(8, 3.5, 0.1), matScreenDark);
             screen.position.z = 0.05; chartGroup.add(screen);
             const barBaseX = -3; const barBaseY = -1.2;
             for(let i=0; i<5; i++) {
                 const h = 1 + Math.random() * 1.5;
                 const color = i % 3 === 0 ? matChartRed : (i % 3 === 1 ? matChartGreen : matChartBlue);
                 const bar = new THREE.Mesh(new THREE.BoxGeometry(0.6, h, 0.2), color);
                 bar.position.set(barBaseX + i*1.0, barBaseY + h/2, 0.2); chartGroup.add(bar);
             }
             const pie = new THREE.Mesh(new THREE.CylinderGeometry(1.0, 1.0, 0.2, 16), matChartYellow);
             pie.rotation.x = Math.PI/2; pie.position.set(3, 0, 0.2); chartGroup.add(pie);
             const slice = new THREE.Mesh(new THREE.BoxGeometry(1.0, 1.0, 0.22), matChartBlue);
             slice.position.set(3.5, 0.5, 0.2); chartGroup.add(slice);
             return chartGroup;
        }
        
        function createStorageRack(x, y, z, rotY=0) {
            const rackGroup = new THREE.Group();
            rackGroup.position.set(x, y, z);
            rackGroup.rotation.y = rotY;
            for(let dx of [-1, 1]) {
                for(let dz of [-0.4, 0.4]) {
                    const leg = new THREE.Mesh(new THREE.BoxGeometry(0.05, 3, 0.05), matRackMetal);
                    leg.position.set(dx, 1.5, dz);
                    rackGroup.add(leg);
                }
            }
            for(let h of [0.2, 1.5, 2.8]) {
                const shelf = new THREE.Mesh(new THREE.BoxGeometry(2.1, 0.05, 0.9), matRackMetal);
                shelf.position.y = h;
                rackGroup.add(shelf);
                const boxCount = Math.floor(Math.random() * 3) + 2;
                for(let k=0; k<boxCount; k++) {
                    const isPlastic = Math.random() > 0.6;
                    const mat = isPlastic ? matPlasticBox : matCardboard;
                    const size = 0.4 + Math.random() * 0.2;
                    const box = new THREE.Mesh(new THREE.BoxGeometry(size, size*0.8, size), mat);
                    box.position.set(-0.8 + k*0.7, h + size*0.4, 0);
                    box.rotation.y = (Math.random() - 0.5) * 0.2;
                    rackGroup.add(box);
                }
            }
            group.add(rackGroup);
        }


        // --- BUILD ---
        const WALL_H = 6; const WALL_T = 0.5;
        
        const ground = new THREE.Mesh(new THREE.PlaneGeometry(200, 200), new THREE.MeshStandardMaterial({color: 0x1a1a1a}));
        ground.rotation.x = -Math.PI/2; ground.position.y = -0.3; scene.add(ground);
        createBox(85, 0.5, 40, 12.5, -0.25, 0, matFloor); 

        // Outer Walls
        createBox(85, WALL_H, WALL_T, 12.5, 3, -20, matWall); // Top
        createBox(WALL_T, WALL_H, 40, -30, 3, 0, matWall); // Left
        createBox(WALL_T, WALL_H, 40, 55, 3, 0, matWall); // Right
        createBox(25, WALL_H, WALL_T, -17.5, WALL_H/2, 20, matWall); // Bot Left
        createBox(50, WALL_H, WALL_T, 30, WALL_H/2, 20, matWall); // Bot Right
        createBox(10, 2, WALL_T, 0, 5, 20, matWall); // Header Door

        // Inner Walls
        createBox(WALL_T, WALL_H, 20, -10, 3, -10, matWall); 
        createBox(WALL_T, WALL_H, 20, 10, 3, -10, matWall);
        createBox(6, WALL_H, WALL_T, -27, 3, 0, matWall);
        createBox(6, WALL_H, WALL_T, -13, 3, 0, matWall);
        createBox(8, 2, WALL_T, -20, 5, 0, matWall);
        createBox(6, WALL_H, WALL_T, -7, 3, 0, matWall);
        createBox(6, WALL_H, WALL_T, 7, 3, 0, matWall);
        createBox(8, 2, WALL_T, 0, 5, 0, matWall);
        createBox(6, WALL_H, WALL_T, 13, 3, 0, matWall);
        createBox(31, WALL_H, WALL_T, 39.5, 3, 0, matWall);
        createBox(8, 2, WALL_T, 20, 5, 0, matWall);
        createBox(25, WALL_H, WALL_T, 42.5, 3, 10, matWall); 
        createBox(WALL_T, WALL_H, 3, 30, 3, 1.5, matWall);
        createBox(WALL_T, WALL_H, 3, 30, 3, 8.5, matWall);
        createBox(WALL_T, 2, 4, 30, 5, 5, matWall);
        createBox(WALL_T, WALL_H, 3, 30, 3, 11.5, matWall);
        createBox(WALL_T, WALL_H, 3, 30, 3, 18.5, matWall);
        createBox(WALL_T, 2, 4, 30, 5, 15, matWall);

        // MEDIA PRODUCTION
        createBox(18, 4.5, 0.2, -20, 2.25, -19.5, matGS); 
        createBox(18, 0.05, 3, -20, 0.06, -18, matGS); 
        createBox(5, 1.2, 1.5, -25, 0.6, -8, matTable); 
        createChair(-25, -6.5, 0); 
        createBox(0.8, 1.5, 1.5, -27, 1.35, -8, matServer); createBox(0.1, 1.2, 0.1, -26.5, 1.35, -7.3, matNeon); 
        createMonitor(-25, 1.2, -8, 0.2); createMonitor(-24, 1.2, -7.8, -0.2); 
        createBox(0.8, 0.1, 0.5, -25, 1.25, -7.5, matDarkGadget); createBox(0.1, 0.8, 0.1, -23.5, 1.6, -8, matDarkGadget); createBox(0.2, 0.4, 0.2, -23.5, 2, -8, new THREE.MeshStandardMaterial({color:0x888888})); 
        createTripodCamera(-20, 0, -12, 0); createSoftbox(-24, 0, -14, 0.5); createSoftbox(-16, 0, -14, -0.5); 
        
        // UX TESTING
        createBox(18, 0.1, 18, 0, 0.05, -10, matCarpet);
        createBox(18, 0.05, 0.1, 0, 0.06, -19, matNeon); createBox(18, 0.05, 0.1, 0, 0.06, -1, matNeon);  
        createBox(0.1, 0.05, 18, -9, 0.06, -10, matNeon); createBox(0.1, 0.05, 18, 9, 0.06, -10, matNeon);  
        createBox(0.4, WALL_H, 0.4, 0, 3, -12, matFurniture); createBox(0.4, WALL_H, 0.4, 0, 3, -18, matFurniture); createBox(0.1, WALL_H, 10, 0, 3, -13, matGlass); 
        createBox(2.5, 1.2, 1.2, -4, 0.6, -12, matTable); createChair(-4, -10.5, 0); createChair(-4, -13.5, Math.PI); 
        createMonitor(-4, 1.2, -12); createPlant(-8, 0, -18); createBox(0.3, 0.05, 0.4, -3.5, 1.22, -12, matPaper); 
        createBox(0.2, 0.02, 0.3, -4.5, 1.22, -11.8, matDarkGadget);
        createBox(5, 1.2, 1.5, 6.5, 0.6, -1.5, matFurniture); createBox(1.5, 1.2, 5, 8.25, 0.6, -4, matFurniture);
        createChair(6.5, -3.5, Math.PI/4); 
        const heatMap = new THREE.Mesh(new THREE.PlaneGeometry(2, 1.5), matHolo);
        heatMap.position.set(6.5, 2.5, -1.5); heatMap.rotation.x = -0.1; group.add(heatMap);
        const cup = new THREE.Mesh(new THREE.CylinderGeometry(0.1, 0.08, 0.2, 16), matCup);
        cup.position.set(8, 1.3, -2); group.add(cup); 
        createBox(0.4, 0.05, 0.3, 5, 1.22, -1.5, matPaper); createBox(0.1, 0.3, 0.1, 8.2, 1.35, -5, matDarkGadget);
        createBox(3.5, 1.2, 1.2, 4, 0.6, -12, matTable); createChair(4, -10.5, 0); createChair(4, -13.5, Math.PI); createMonitor(4, 1.2, -12);
        createBox(0.3, 0.05, 0.4, 4.5, 1.22, -12, matPaper);
        createBox(1.5, 3.5, 1.5, 9, 1.75, -10, matServer); createBox(1.2, 0.1, 0.1, 9, 3, -9.2, matNeon); 
        createBox(3, 0.2, 0.8, 9, 3, -16, matWoodAccent); createBox(3, 0.2, 0.8, 9, 4, -16, matWoodAccent);
        createBox(0.5, 0.4, 0.5, 9, 3.3, -16, matFurniture); createBox(0.2, 0.3, 0.2, 8.5, 3.25, -16, matCup); 
        const posterGeo = new THREE.BoxGeometry(0.1, 2, 1.5);
        const poster = new THREE.Mesh(posterGeo, new THREE.MeshStandardMaterial({color: 0x336699})); 
        poster.position.set(9.9, 3, -6); group.add(poster);

        // VR (UPDATED)
        const vrRingGeo = new THREE.RingGeometry(7, 7.2, 64);
        const vrRing = new THREE.Mesh(vrRingGeo, new THREE.MeshBasicMaterial({color: 0x00d2ff, side: THREE.DoubleSide}));
        vrRing.rotation.x = -Math.PI/2; vrRing.position.set(32.5, 0.05, -10); group.add(vrRing);
        createBox(0.2, WALL_H, 0.1, 20, 3, -19.8, matNeon); createBox(0.2, WALL_H, 0.1, 45, 3, -19.8, matNeon);
        createSensor(15, 5, -19.5); createSensor(50, 5, -19.5); createSensor(10.5, 5, -5); createSensor(54.5, 5, -5);
        
        // GLASS CABINET ON LEFT WALL (X=15, Z=-19.5) Facing East
        createVRCabinet(15, 0, -19.5, 0); 
        
        // NEW: WALL TV ON RIGHT WALL OF VR ROOM (Facing Left/West) (X=54.6, Z=-10)
        createWallTV(54.6, 3.5, -10, Math.PI); // Rotate 180 to face left?
        const holoCube = new THREE.Mesh(new THREE.BoxGeometry(0.4, 0.4, 0.4), matHolo);
        holoCube.position.set(32.5, 2.2, -10);
        holoCube.rotation.x = Math.PI/4; holoCube.rotation.z = Math.PI/4; group.add(holoCube);
        function animateHolo() { holoCube.rotation.y += 0.01; requestAnimationFrame(animateHolo); }
        animateHolo();
        createBox(1.5, 1.2, 8, 53.5, 0.6, -10, matTable); 
        createChair(51.5, -8, 0); createChair(51.5, -12, 0);
        createMonitor(53.5, 1.2, -8, -Math.PI/2); createMonitor(53.5, 1.2, -12, -Math.PI/2);

        // AI
        for(let z=1; z<9; z+=2) { createBox(0.2, 4, 0.5, 54.8, 3, z, matWoodAccent); }
        const dbScreen = createChartScreen(54.6, 3.5, 5); group.add(dbScreen);
        createBox(1.5, 1.2, 18, 51, 0.6, 5, matTable); 
        createChair(48.5, 2, -Math.PI/2); createMonitor(51, 1.2, 2, -Math.PI/2); createMonitor(51, 1.2, 1, -Math.PI/2 - 0.2);
        createChair(48.5, 5, -Math.PI/2); createMonitor(51, 1.2, 5, -Math.PI/2); createMonitor(51, 1.2, 4, -Math.PI/2 - 0.2); createMonitor(51, 1.2, 6, -Math.PI/2 + 0.2);
        createChair(48.5, 8, -Math.PI/2); createMonitor(51, 1.2, 8, -Math.PI/2);
        createServerRack(52, 0, 1.5, Math.PI/2);
        const lightPanel = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), matCeilingLight);
        lightPanel.rotation.x = Math.PI/2; lightPanel.position.set(42, 5.9, 5); group.add(lightPanel);
        const lightPanel2 = lightPanel.clone(); lightPanel2.position.set(48, 5.9, 5); group.add(lightPanel2);

        // STORAGE
        createStorageRack(53, 0, 12.5, Math.PI/2); createStorageRack(53, 0, 15.0, Math.PI/2); createStorageRack(53, 0, 17.5, Math.PI/2);
        createStorageRack(32, 0, 12.0, Math.PI/2); createStorageRack(32, 0, 18.0, Math.PI/2);
        createStorageRack(35, 0, 19, 0); createStorageRack(40, 0, 19, 0); createStorageRack(45, 0, 19, 0); createStorageRack(50, 0, 19, 0);
        createBox(3, 1.0, 1.5, 42.5, 0.5, 15, matTable); createBox(0.5, 0.5, 0.5, 43, 1.25, 15, matCardboard); createBox(0.1, 0.1, 1, 42, 1.05, 15, matDarkGadget); 
        const storeLight = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), matCeilingLight);
        storeLight.rotation.x = Math.PI/2; storeLight.position.set(42.5, 5.9, 15); group.add(storeLight);
        createBox(0.6, 0.6, 0.6, 38, 0.3, 14, matCardboard); createBox(0.6, 0.6, 0.6, 38, 0.9, 14, matCardboard); createBox(0.5, 0.5, 0.5, 38.6, 0.25, 14.2, matPlasticBox);
        createClosedCabinet(40, 0, 19.2, 0); createClosedCabinet(45, 0, 19.2, 0);
        
        // COLLAB
        for(let x=-28; x<52; x+=4) { if (Math.abs(x) < 6) continue; createBox(0.5, 4, 0.2, x, 3, 19.8, matWoodPanel); }
        const tableGeo = new THREE.CylinderGeometry(1, 1, 0.2, 64); 
        const table = new THREE.Mesh(tableGeo, matWhiteTable);
        table.position.set(0, 0.8, 10); table.scale.set(12, 1, 4); group.add(table);
        for(let x = 0 - 8; x <= 0 + 8; x += 4) {
             createModernChair(x, 0, 14.5, 0); createModernChair(x, 0, 5.5, Math.PI); 
             createBox(0.8, 0.05, 0.6, x, 0.92, 12, matLaptop); createBox(0.8, 0.05, 0.6, x, 0.92, 8, matLaptop);
        }
        createModernChair(0 - 13, 0, 10, -Math.PI/2); createModernChair(0 + 13, 0, 10, Math.PI/2);  
        const collabScreen = new THREE.Mesh(new THREE.PlaneGeometry(20, 3), matCityLights);
        collabScreen.position.set(0, 3.5, 19.7); group.add(collabScreen);
        createPlant(-25, 0, 18); createPlant(50, 0, 18);
        createWallTV(-29.5, 3.5, 10, 0); 

        // ZONES
        const zones = [];
        function createZone(id, w, d, x, z) {
            const geo = new THREE.PlaneGeometry(w, d);
            const mat = new THREE.MeshBasicMaterial({ visible: false }); 
            const mesh = new THREE.Mesh(geo, mat);
            mesh.rotation.x = -Math.PI/2; mesh.position.set(x, 0.5, z);
            mesh.userData = { id: id }; group.add(mesh); zones.push(mesh);
        }
        createZone("production", 20, 20, -20, -10); createZone("ux", 20, 20, 0, -10);
        createZone("vr", 45, 20, 32.5, -10); createZone("ai", 25, 10, 42.5, 5);
        createZone("storage", 25, 10, 42.5, 15); createZone("collab", 45, 20, 0, 10);

        // LOGIC
        const raycaster = new THREE.Raycaster();
        const mouse = new THREE.Vector2();
        const keys = { w: false, a: false, s: false, d: false };
        window.addEventListener('keydown', (e) => { if(e.key === 'Escape' && isFPV) exitFPV(); keys[e.key.toLowerCase()] = true; });
        window.addEventListener('keyup', (e) => { keys[e.key.toLowerCase()] = false; });
        window.enterFPV = function() {
            isFPV = true;
            document.getElementById('start-fpv-btn').style.display = 'none'; document.getElementById('esc-hint').style.display = 'block';
            document.getElementById('help-overview').style.display = 'none'; document.getElementById('help-fpv').style.display = 'block';
            renderer.domElement.focus();
            gsap.to(camera.position, { x: POS_FPV.x, y: POS_FPV.y, z: POS_FPV.z, duration: 1.5, ease: "power2.inOut" });
            gsap.to(controls.target, { x: TARGET_FPV.x, y: TARGET_FPV.y, z: TARGET_FPV.z, duration: 1.5, ease: "power2.inOut", onComplete: () => { controls.minDistance = 0.1; controls.enablePan = false; } });
        };
        function exitFPV() {
            isFPV = false;
            document.getElementById('start-fpv-btn').style.display = 'block'; document.getElementById('esc-hint').style.display = 'none';
            document.getElementById('help-overview').style.display = 'block'; document.getElementById('help-fpv').style.display = 'none';
            controls.enablePan = true;
            gsap.to(camera.position, { x: POS_OVERVIEW.x, y: POS_OVERVIEW.y, z: POS_OVERVIEW.z, duration: 1.5, ease: "power2.inOut" });
            gsap.to(controls.target, { x: TARGET_OVERVIEW.x, y: TARGET_OVERVIEW.y, z: TARGET_OVERVIEW.z, duration: 1.5, ease: "power2.inOut" });
        }
        let isDragging = false; let startX = 0, startY = 0;
        renderer.domElement.addEventListener('mousedown', (e) => { isDragging = false; startX = e.clientX; startY = e.clientY; });
        renderer.domElement.addEventListener('mousemove', (e) => { if(Math.abs(e.clientX - startX) > 3 || Math.abs(e.clientY - startY) > 3) isDragging = true; });
        renderer.domElement.addEventListener('mouseup', (e) => {
            if(isDragging || isFPV) return; 
            mouse.x = (e.clientX / window.innerWidth) * 2 - 1; mouse.y = -(e.clientY / window.innerHeight) * 2 + 1;
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObjects(zones);
            if(intersects.length > 0) {
                const obj = intersects[0].object; const data = labData[obj.userData.id];
                const ui = document.getElementById('ui-container'); ui.style.display = 'block';
                document.getElementById('room-name').textContent = data.name;
                document.getElementById('room-desc').textContent = data.desc;
                // FIXED: use string/backticks for innerHTML (was syntax error previously)
                document.getElementById('room-tech').innerHTML = `<span class="tag">${data.tech}</span>`;
                gsap.to(controls.target, { x: obj.position.x, y: 0, z: obj.position.z, duration: 1 });
            } else { document.getElementById('ui-container').style.display = 'none'; }
        });
        function updateMovement() {
            if(!isFPV) return;
            const speed = 0.6; const dir = new THREE.Vector3(); camera.getWorldDirection(dir); dir.y = 0; dir.normalize();
            const right = new THREE.Vector3().crossVectors(dir, camera.up).normalize();
            const move = new THREE.Vector3();
            if(keys.w) move.addScaledVector(dir, speed); if(keys.s) move.addScaledVector(dir, -speed);
            if(keys.a) move.addScaledVector(right, -speed); if(keys.d) move.addScaledVector(right, speed);
            if(move.length() > 0) { camera.position.add(move); controls.target.add(move); }
            if(camera.position.x < -29) { camera.position.x = -29; controls.target.x = -29 + dir.x; }
            if(camera.position.x > 54) { camera.position.x = 54; controls.target.x = 54 + dir.x; }
            if(camera.position.z < -19) { camera.position.z = -19; controls.target.z = -19 + dir.z; }
        }
        function animate() { requestAnimationFrame(animate); updateMovement(); controls.update(); renderer.render(scene, camera); }
        animate();

        window.addEventListener('resize', () => {
            // keep pixel ratio in sync on resize (Hi-DPI)
            renderer.setPixelRatio(Math.min(window.devicePixelRatio || 1, 2));
            camera.aspect = window.innerWidth/window.innerHeight; camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }
    </script>
</body>
</html>
